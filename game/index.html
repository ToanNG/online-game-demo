<!DOCTYPE html>
<html>
<head>
	<title>Impact Game</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	<style type="text/css">
		html, body {
			background-color: #000;
			color: #fff;
			font-family: helvetica, arial, sans-serif;
			margin: 0;
			padding: 0;
			font-size: 12pt;
		}

		#canvas {
			display: none;
			position: absolute;
			left: 0;
			right: 0;
			top: 0;
			bottom: 0;
			margin: auto;
			border: 1px solid #555;
		}

		canvas {
			display: block;
			width: 100%;
			height: 100%;
		}

		#container {
      width: 100%;
      height: 100%;
      background-color: gray;
    }
	</style>

	<!-- <script src="/socket.io/socket.io.js"></script> -->
	<script type="text/javascript" src="lib/three.js"></script>
	<script type="text/javascript" src="lib/impact/impact.js"></script>
	<script type="text/javascript" src="lib/game/main.js"></script>
</head>
<body>
	<div id="container"></div>

	<script type="text/javascript">
		var inputName = "Toan",
				gameScreen = {};
	</script>

	<script>
    var isUpDown,
        isDownDown,
        isLeftDown,
        isRightDown;
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
    var renderer = new THREE.WebGLRenderer();
    renderer.setClearColor( 0xf0f0f0 );
    renderer.setSize( window.innerWidth/2, window.innerHeight/2 );
    container = document.getElementById( 'container' );
    container.appendChild( renderer.domElement );

    var geometry = new THREE.CubeGeometry(32,32,32,1,1,1);
    var material = new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true } );
    var cube = new THREE.Mesh( geometry, material );
    scene.add( cube );
    camera.position.z = 600;
    camera.position.y = 600;

    axes = new THREE.AxisHelper( 1000 );
    scene.add( axes );



    // grid

    var size = 320, step = 32;

    var geometry = new THREE.Geometry();

    for ( var i = - size; i <= size; i += step ) {

      geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
      geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

      geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
      geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );

    }

    var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2, transparent: true } );

    var line = new THREE.Line( geometry, material );
    line.type = THREE.LinePieces;
    scene.add( line );

    plane = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000 ), new THREE.MeshBasicMaterial() );
    plane.rotation.x = - Math.PI / 2;
    plane.visible = false;
    scene.add( plane );

    document.addEventListener( 'keydown', onDocumentKeyDown, false );
    document.addEventListener( 'keyup', onDocumentKeyUp, false );
    function onDocumentKeyDown( event ) {
      switch( event.keyCode ) {
        case 37: isLeftDown = true; break;
        case 38: isUpDown = true; break;
        case 39: isRightDown = true; break;
        case 40: isDownDown = true; break;
      }
    }
    function onDocumentKeyUp( event ) {
      switch ( event.keyCode ) {
        case 37: isLeftDown = false; break;
        case 38: isUpDown = false; break;
        case 39: isRightDown = false; break;
        case 40: isDownDown = false; break;
      }
    }

    function render() {
      requestAnimationFrame(render);
      // cube.rotation.x += 0.01;
      // cube.rotation.y += 0.01;
      var speed = 10;

      if (isUpDown) {
        cube.position.z -= speed;
      }
      if(isDownDown) {
        cube.position.z += speed;
      }
      if (isLeftDown) {
        cube.position.x -= speed;
      }
      if (isRightDown) {
        cube.position.x += speed;
      }

      camera.lookAt( scene.position );
      renderer.render(scene, camera);
    }
    render();
  </script>

	<canvas id="canvas"></canvas>
	<!-- 
	<script type="text/javascript">
		var inputName = window.prompt("Please enter your name"),
			gameScreen = {};

		var socket = io.connect(window.location.origin);

		socket.on("connect", function() {
			socket.on("setIndex", function(newPlayerIndex) {
				var player = ig.game.getEntitiesByType(EntityPlayer)[0];
				player.index = newPlayerIndex;
			});

			socket.on("addPlayer", function(playerList) {
				var player = ig.game.getEntitiesByType(EntityPlayer)[0];

				for (var i = 0; i < playerList.length; i++) {
					if (player.name != playerList[i].name) {
						ig.game.spawnEntity(EntityOtherPlayer, playerList[i].lastPos.x, playerList[i].lastPos.y, {name: playerList[i].name});
					}
				}
			});

			socket.on("updateOtherPlayer", function(otherPlayerName, direction, target) {
				if (!ig.game) return;

				var otherPlayer = ig.game.getEntitiesByType(EntityOtherPlayer);

				if (otherPlayer) {
					for (var i in otherPlayer) {
						if (otherPlayerName == otherPlayer[i].name) {
							otherPlayer[i].targetX = target.x;
							otherPlayer[i].targetY = target.y;
							otherPlayer[i].direction = direction;
						}
					}
				}
			});

			socket.on("removePlayer", function(playerList) {
				var otherPlayer = ig.game.getEntitiesByType(EntityOtherPlayer),
					player = ig.game.getEntitiesByType(EntityPlayer)[0];
				
				if (otherPlayer) {
					for (var i = 0; i < otherPlayer.length; i++) {
						otherPlayer[i].kill();
					}
				}

				for (var i = 0; i < playerList.length; i++) {
					if (inputName != playerList[i].name) {
						ig.game.spawnEntity(EntityOtherPlayer, playerList[i].lastPos.x, playerList[i].lastPos.y, {name: playerList[i].name});
					} else {
						player.index = i;
					}
				}
			});
		});
	</script> 
	-->
</body>
</html>
